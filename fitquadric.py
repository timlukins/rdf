# Autogenerated with SMOP version 
# /usr/local/bin/smop dum_fitquadric.m -o dum_fitquadric.py
from __future__ import division
from runtime import *

def fitquadric(pm_P,varargin,nargout=1):
    V=copy_(pm_P)
    lc_type='general'
    lf_show=copy_(false)
    lf_align=copy_(false)
    lf_algebraic=copy_(true)
    lf_euclidean=copy_(false)
    lf_genetic=copy_(false)
    if (size_(pm_P,1) != 3 and size_(pm_P,2) == 3):
        lf_align=copy_(true)
        ls_n=sqrt_(size_(pm_P,1))
    if (mod_(length_(varargin),2) == 0):
        for a in arange_(1,length_(varargin),2).reshape(-1):
            if 'type' == (lower_____(varargin[a])):
                lc_type=varargin[a + 1]
            else:
                if 'show' == (lower_____(varargin[a])):
                    lf_show=varargin[a + 1]
                else:
                    if 'algebraic' == (lower_____(varargin[a])):
                        lf_algebraic=varargin[a + 1]
                    else:
                        if 'euclidean' == (lower_____(varargin[a])):
                            lf_euclidean=varargin[a + 1]
                        else:
                            if 'genetic' == (lower_____(varargin[a])):
                                lf_genetic=varargin[a + 1]
                            else:
                                disp_(sprintf_('Unknown option: %s',varargin[a]))
    Q=zeros_(5,1)
    if (lf_align):
        ls_mu=pm_P[((size_(pm_P,1) + 1) / 2),:]
        lm_A=matlabarray([pm_P[:,1] - ls_mu[1],pm_P[:,2] - ls_mu[2],pm_P[:,3] - ls_mu[3]])
        U,S,W=svd_(lm_A,0,nargout=3)
        s,i=min_(diag_(S),nargout=2)
        a=W[1,i]
        b=W[2,i]
        c=W[3,i]
        if (c < 0):
            n=matlabarray([- a,- b,- c])
        else:
            n=matlabarray([a,b,c])
        once=1
        while (n[3] != 1.0 or once):

            n=n / norm_(n)
            r3=copy_(n)
            r1=((eye_(3) - n * n.T) * [0,0,1].T)
            r1=r1.T / norm_(r1)
            r2=cross_(r3,r1)
            R=matlabarray([[r1],[r2],[r3]])
            ls_mu=pm_P[((size_(pm_P,1) + 1) / 2),:]
            pm_P=pm_P - (ones_(size_(pm_P,1),1) * ls_mu)
            pm_P=(R * pm_P.T).T
            V=copy_(pm_P)
            lm_R=matlabarray([pm_P[:,1] ** 2,pm_P[:,1].dot(pm_P[:,2]),pm_P[:,2] ** 2,pm_P[:,1],pm_P[:,2]])
            lv_S=pm_P[:,3]
            Q=lscov_(lm_R,lv_S)
            n=[- Q[4],- Q[5],1] / (1 + Q[4] ** 2 + Q[5] ** 2)
            once=0

        pm_P=reshape_(pm_P[:,3],ls_n,ls_n)
    ls_xs=size_(pm_P,1)
    ls_ys=size_(pm_P,2)
    lv_xx=linspace_(- 1,1,ls_xs)
    lv_yy=linspace_(- 1,1,ls_ys)
    if (strcmp_(lc_type,'principal')):
        rv_coeffs=Q[1:3,:]
        ls_err=minfit_(rv_coeffs,pm_P)
    else:
        rv_coeffs=rand_(10,1)
        if (lf_algebraic):
            lm_H=zeros_(10)
            lm_DH=zeros_(10)
            for xi in arange_(1,ls_xs).reshape(-1):
                for yi in arange_(1,ls_ys).reshape(-1):
                    x=lv_xx[xi]
                    y=lv_yy[yi]
                    z=pm_P[xi,yi]
                    lv_h=[x ** 2,y ** 2,z ** 2,2 * x * y,2 * x * z,2 * y * z,2 * x,2 * y,2 * z,1].T
                    lm_H=lm_H + lv_h * lv_h.T
                    J=matlabarray([[[2 * x,0,0]],[[0,2 * y,0]],[[0,0,2 * z]],[[2 * y,2 * x,0]],[[2 * z,0,2 * x]],[[0,2 * z,2 * y]],[[2,0,0]],[[0,2,0]],[[0,0,2]],[[0,0,0]]])
                    lm_DH=lm_DH + J * J.T
            warning_('off')
            lm_vects,lm_vals=eigs_(lm_H,lm_DH,10,nargout=2)
            rv_coeffs=lm_vects[1:10,size_(lm_vals,1)]
        ls_err=minfit_(rv_coeffs,pm_P)
        if (lf_genetic):
            ls_p=100
            ls_o=10
            ls_top=0.1
            ls_mu=0.05
            ls_maxg=100
            lm_pop=ones_(ls_p,1) * rv_coeffs.T
            lm_pop[round_(ls_p / 2) + 1:ls_p,:]=lm_pop[round_(ls_p / 2) + 1:ls_p,:] + rand_(round_(ls_p / 2),10)
            ls_best=0.0
            ls_deltabest=0.0
            lv_index=zeros_(ls_p,1)
            lm_npop=zeros_(ls_p,ls_o)
            for g in arange_(1,ls_maxg).reshape(-1):
                for i in arange_(1,ls_p).reshape(-1):
                    lv_besti[i]=minfit_(lm_pop[i,:].T,pm_P)
                lv_besti,lv_index=sort_(lv_besti,nargout=2)
                ls_best=lv_besti[1]
                if (g == ls_p):
                    break
                for i in arange_(1,ls_p).reshape(-1):
                    if (i <= round_(ls_top * ls_p)):
                        lm_npop[i,:]=lm_pop[lv_index[i],:]
                    else:
                        father=ceil_(rand_() * ls_p)
                        mother=ceil_(rand_() * ls_p)
                        lm_npop[i,:]=breed_(lm_pop[father,:],lm_pop[mother,:])
                        if (rand_() < ls_mu):
                            lm_npop[i,:]=mutate_(lm_npop[i,:])
                lm_pop=copy_(lm_npop)
            rv_coeffs=lm_pop[lv_index[1],:]
    ls_err=minfit_(rv_coeffs,pm_P)
    if (lf_euclidean):
        lt_optoptions=optimset_('Display','off','FunValCheck','on','TolX',1e-11,'TolFun',1e-11,'MaxFunEvals',1000,'MaxIter',1000)
        rv_coeffs,ls_err,ls_flag=fminsearch_(minfit,rv_coeffs,lt_optoptions,pm_P,nargout=3)
    varargout[1]=ls_err
    if (lf_show):
        clf
        plot3_(V[:,1],V[:,2],V[:,3],'r+')
        W=quadric_(ls_n,ls_n,rv_coeffs)
        W=reshape_(W,ls_n ** 2,1)
        hold_('on')
        plot3_(V[:,1],V[:,2],W,'bx')
        legend_('data','quadric')
        drawnow
    return rv_coeffs,varargout
def minfit_(pv_coeffs,pm_P,nargout=1):
    lm_X=quadric_(size_(pm_P,1),size_(pm_P,2),pv_coeffs)
    lv_dist=reshape_(abs_(pm_P - lm_X),size_(pm_P,1) * size_(pm_P,2),1)
    rs_err=mean_(lv_dist ** 2)
    return rs_err
def breed_(lm_father,lm_mother,nargout=1):
    ls_len=size_(lm_father,2)
    ls_at=ceil_(ls_len * rand_())
    rm_new[1,:]=lm_father[1,:]
    rm_new[1,ls_at:ls_len]=lm_mother[1,ls_at:ls_len]
    return rm_new
def mutate_(lm_this,nargout=1):
    ls_len=size_(lm_this,2)
    ls_at=ceil_(ls_len * rand_())
    rm_new[1,:]=lm_this[1,:]
    rm_new[1,ls_at]=rm_new[1,ls_at] + rand_()
    return rm_new
