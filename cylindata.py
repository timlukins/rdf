# Autogenerated with SMOP version 
# /usr/local/bin/smop cylindata.m
from __future__ import division
from runtime import *

def cylindata(r,theta,d,mx,my,nargout=1):
    lm_sz,lm_sy,lm_sx=cylinder_(r,d,nargout=3)
    lm_sx=(lm_sx * 2 * r) - r
    ls_pts=0
    for x in arange_(1,size_(lm_sx,1)).reshape(-1):
        for y in arange_(1,size_(lm_sy,2)).reshape(-1):
            if (lm_sz[x,y] > 0):
                ls_pts=ls_pts + 1
                lm_nx[ls_pts]=lm_sx[x,y]
                lm_ny[ls_pts]=lm_sy[x,y]
                lm_nz[ls_pts]=lm_sz[x,y]
    R=matlabarray([[cos_(theta),- sin_(theta),0],[sin_(theta),cos_(theta),0],[0,0,1]])
    T=[mx,my,0].T
    M=matlabarray([[R,T],[0,0,0,1]])
    pts=matlabarray([[lm_nx],[lm_ny],[lm_nz],[ones_(1,ls_pts)]])
    npts=(M * pts).T
    lm_nx=npts[:,1]
    lm_ny=npts[:,2]
    lm_nz=npts[:,3]
    f=matlabarray([lm_nx,lm_ny])
    x,y=meshgrid_(linspace_(- 1,1,d),linspace_(- 1,1,d),nargout=2)
    z=griddata_(lm_nx,lm_ny,lm_nz,x,y)
    for xi in arange_(1,size_(z,1)).reshape(-1):
        for yi in arange_(1,size_(z,2)).reshape(-1):
            if (isnan_(z[xi,yi])):
                z[xi,yi]=0
    return x,y,z,f
