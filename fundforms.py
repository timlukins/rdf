# Autogenerated with SMOP version 
# /usr/local/bin/smop fundforms.m -o fundforms.py
from __future__ import division
from runtime import *

def fundforms(dx,dy,varargin,nargout=1):
    if (length_(varargin) == 3):
        x=varargin[1]
        y=varargin[2]
        z=varargin[3]
        doquadric=copy_(false)
        I=zeros_(size_(z,1),size_(z,2),2,2)
        II=zeros_(size_(z,1),size_(z,2),2,2)
        III=zeros_(size_(z,1),size_(z,2),2,2)
    else:
        if (length_(varargin) == 1):
            d=varargin[1]
            if (size_(d,1) != 3 and size_(d,2) != 3):
                disp_('Data is not Nx3 array in fundforms')
                return I,II,III,varargout
            doquadric=copy_(true)
            I=zeros_(2,2)
            II=zeros_(2,2)
            III=zeros_(2,2)
        else:
            disp_('Incorrect data input to dum_fundforms')
            return I,II,III,varargout
    if (doquadric):
        q=fitquadric_(d,'type','principal','euclidean',true)
        if (nargout == 4):
            trans=d[((size_(d,1) + 1) / 2),3]
            nd=quadric_(sqrt_(length_(d)),sqrt_(length_(d)),q)
            nd=nd + (ones_(size_(nd,1),size_(nd,2)) * trans)
            varargout[1]=[nd]
        a=q[1]
        b=q[2]
        c=q[3]
        x=copy_(dx)
        y=copy_(dy)
        Xu=matlabarray([x,0,2 * a * x + b * y])
        Xv=matlabarray([0,y,b * x + 2 * c * y])
        E=dot_(Xu,Xu)
        F=dot_(Xu,Xv)
        G=dot_(Xv,Xv)
        Xuu=matlabarray([0,0,2 * a])
        Xuv=matlabarray([0,0,b])
        Xvv=matlabarray([0,0,2 * c])
        n=matlabarray([0,0,1])
        L=dot_(Xuu,n)
        M=dot_(Xuv,n)
        N=dot_(Xvv,n)
        I=matlabarray([[E,F],[F,G]])
        II=matlabarray([[L,M],[M,N]])
        H=(E * N + G * L - 2 * F * M) / (2 * (E * G - F ** 2))
        K=(L * N - M ** 2) / (E * G - F ** 2)
        III=2 * H * II - K * I
    else:
        xu,xv=gradient_(x,nargout=2)
        xuu,xuv=gradient_(xu,nargout=2)
        xvu,xvv=gradient_(xv,nargout=2)
        yu,yv=gradient_(y,nargout=2)
        yuu,yuv=gradient_(yu,nargout=2)
        yvu,yvv=gradient_(yv,nargout=2)
        zu,zv=gradient_(z,nargout=2)
        zuu,zuv=gradient_(zu,nargout=2)
        zvu,zvv=gradient_(zv,nargout=2)
        for i in arange_(1,(size_(z,1))).reshape(-1):
            for j in arange_(1,(size_(z,2))).reshape(-1):
                Xu=matlabarray([xu[i,j],yu[i,j],zu[i,j]])
                Xv=matlabarray([xv[i,j],yv[i,j],zv[i,j]])
                Xuu=matlabarray([xuu[i,j],yuu[i,j],zuu[i,j]])
                Xuv=matlabarray([xuv[i,j],yuv[i,j],zuv[i,j]])
                Xvv=matlabarray([xvv[i,j],yvv[i,j],zvv[i,j]])
                E=dot_(Xu,Xu)
                F=dot_(Xu,Xv)
                G=dot_(Xv,Xv)
                m=cross_(Xu,Xv)
                n=m / sqrt_(sum_(m.dot(m)))
                L=dot_(Xuu,n)
                M=dot_(Xuv,n)
                N=dot_(Xvv,n)
                I[i,j,:,:]=[[E,F],[F,G]]
                II[i,j,:,:]=[[L,M],[M,N]]
                H=(E * N + G * L - 2 * F * M) / (2 * (E * G - F ** 2))
                K=(L * N - M ** 2) / (E * G - F ** 2)
                III[i,j,:,:]=2 * H * II[i,j,:,:] - K * I[i,j,:,:]
    return I,II,III,varargout
