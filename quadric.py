# Autogenerated with SMOP version 
# /usr/local/bin/smop dum_quadric.m -o dum_quadric.py
from __future__ import division
from runtime import *

def quadric(pm_x,pm_y,pv_coeffs,nargout=1):
    if (size_(pm_x,1) == 1 and size_(pm_y,2) == 1):
        pv_x=linspace_(- 1,1,pm_x)
        pv_y=linspace_(- 1,1,pm_y)
    else:
        disp_('quadric needs just the resolution!')
    if (length_(pv_coeffs) == 3):
        for xi in arange_(1,length_(pv_x)).reshape(-1):
            for yi in arange_(1,length_(pv_y)).reshape(-1):
                a=pv_coeffs[1]
                b=pv_coeffs[2]
                c=pv_coeffs[3]
                x=pv_x[xi]
                y=pv_y[yi]
                z[xi,yi]=a * x ** 2 + b * x * y + c * y ** 2
    else:
        if (length_(pv_coeffs) == 10):
            raytrace=copy_(false)
            if (not raytrace):
                a=pv_coeffs[1]
                b=pv_coeffs[2]
                c=pv_coeffs[3]
                h=pv_coeffs[4]
                g=pv_coeffs[5]
                f=pv_coeffs[6]
                u=pv_coeffs[7]
                v=pv_coeffs[8]
                w=pv_coeffs[9]
                d=pv_coeffs[10]
                for xi in arange_(1,length_(pv_x)).reshape(-1):
                    for yi in arange_(1,length_(pv_y)).reshape(-1):
                        x=pv_x[xi]
                        y=pv_y[yi]
                        z1=(- 2 * g * x - 2 * w - 2 * f * y + 2 * (g ** 2 * x ** 2 + 2 * g * x * w + 2 * g * x * f * y + w ** 2 + 2 * w * f * y + f ** 2 * y ** 2 - c * a * x ** 2 - c * b * y ** 2 - 2 * c * u * x - 2 * c * h * x * y - c * d - 2 * c * v * y) ** (1 / 2)) / (2 * c)
                        z2=(- 2 * g * x - 2 * w - 2 * f * y - 2 * (g ** 2 * x ** 2 + 2 * g * x * w + 2 * g * x * f * y + w ** 2 + 2 * w * f * y + f ** 2 * y ** 2 - c * a * x ** 2 - c * b * y ** 2 - 2 * c * u * x - 2 * c * h * x * y - c * d - 2 * c * v * y) ** (1 / 2)) / (2 * c)
                        if (abs_(z1) < abs_(z2)):
                            z[xi,yi]=real_(z1)
                        else:
                            z[xi,yi]=real_(z2)
            else:
                a=pv_coeffs[1]
                e=pv_coeffs[2]
                h=pv_coeffs[3]
                b=pv_coeffs[4]
                c=pv_coeffs[5]
                f=pv_coeffs[6]
                d=pv_coeffs[7]
                g=pv_coeffs[8]
                i=pv_coeffs[9]
                j=pv_coeffs[10]
                z=zeros_(length_(pv_x),length_(pv_y))
                for x in arange_(1,length_(pv_x)).reshape(-1):
                    for y in arange_(1,length_(pv_y)).reshape(-1):
                        t=1.0
                        xo=pv_x[x]
                        yo=pv_y[y]
                        zo=0
                        xd=0
                        yd=0
                        zd=1
                        Aq=a * xd ** 2 + 2 * b * xd * yd + 2 * c * xd * zd + e * yd ** 2 + 2 * f * yd * zd + h * zd ** 2
                        Bq=2 * (a * xo * xd + b * (xo * yd + xd * yo) + c * (xo * zd + xd * zo) + d * xd + e * yo * yd + f * (yo * zd + yd * zo) + g * yd + h * zo * zd + i * zd)
                        Cq=a * xo ** 2 + 2 * b * xo * yo + 2 * c * xo * zo + 2 * d * xo + e * yo ** 2 + 2 * f * yo * zo + 2 * g * yo + h * zo ** 2 + 2 * i * zo + j
                        if (Aq == 0):
                            z[x,y]=- Cq / Bq
                        else:
                            if ((Bq ** 2 - 4 * Aq * Cq) < 0):
                                z[x,y]=0.0
                            else:
                                t=(- Bq - sqrt_(Bq ** 2 - 4 * Aq * Cq)) / (2 * Aq)
                                if (t < 0.0):
                                    t=(- Bq + sqrt_(Bq ** 2 - 4 * Aq * Cq)) / (2 * Aq)
                        z[x,y]=t
            if (nargout == 2):
                a=pv_coeffs[1]
                b=pv_coeffs[2]
                c=pv_coeffs[3]
                h=pv_coeffs[4]
                g=pv_coeffs[5]
                f=pv_coeffs[6]
                p=pv_coeffs[7]
                q=pv_coeffs[8]
                r=pv_coeffs[9]
                d=pv_coeffs[10]
                lm_e=matlabarray([[a,h,g],[h,b,f],[g,f,c]])
                lm_E=matlabarray([[a,h,g,p],[h,b,f,q],[g,f,c,r],[p,q,r,d]])
                p3=rank_(lm_e)
                p4=rank_(lm_E)
                delta=det_(lm_E)
                ksame=ksigns_(eig_(lm_e))
                Ksame=ksigns_(eig_(lm_E))
                _type=0
                if (p3 == 3 and p4 == 4 and delta < 0 and ksame):
                    _type=1
                else:
                    if (p3 == 3 and p4 == 4 and delta > 0 and ksame):
                        _type=2
                    else:
                        if (p3 == 3 and p4 == 4 and delta > 0 and not ksame):
                            _type=3
                        else:
                            if (p3 == 3 and p4 == 4 and delta < 0 and not ksame):
                                _type=4
                            else:
                                if (p3 == 3 and p4 == 3 and not ksame):
                                    _type=5
                                else:
                                    if (p3 == 3 and p4 == 3 and ksame):
                                        _type=6
                                    else:
                                        if (p3 == 2 and p4 == 4 and delta < 0 and ksame):
                                            _type=7
                                        else:
                                            if (p3 == 2 and p4 == 4 and delta > 0 and not ksame):
                                                _type=8
                                            else:
                                                if (p3 == 2 and p4 == 3 and ksame and not Ksame):
                                                    _type=9
                                                else:
                                                    if (p3 == 2 and p4 == 3 and ksame and Ksame):
                                                        _type=10
                                                    else:
                                                        if (p3 == 2 and p4 == 3 and not ksame):
                                                            _type=11
                                                        else:
                                                            if (p3 == 2 and p4 == 2 and not ksame):
                                                                _type=12
                                                            else:
                                                                if (p3 == 2 and p4 == 2 and ksame):
                                                                    _type=13
                                                                else:
                                                                    if (p3 == 1 and p4 == 3):
                                                                        _type=14
                                                                    else:
                                                                        if (p3 == 1 and p4 == 2 and not Ksame):
                                                                            _type=15
                                                                        else:
                                                                            if (p3 == 1 and p4 == 2 and Ksame):
                                                                                _type=16
                                                                            else:
                                                                                if (p3 == 1 and p4 == 1):
                                                                                    _type=17
                varargout[1]=[_type]
        else:
            disp_('Unrecognised number of quadric coefficients!')
    return z,varargout
def ksigns_(vals,nargout=1):
    pos=0
    neg=0
    zer=0
    same=copy_(false)
    for v in arange_(1,length_(vals)).reshape(-1):
        if (vals[v] > 0):
            pos=pos + 1
        if (vals[v] < 0):
            neg=neg + 1
        if (vals[v] == 0):
            zer=zer + 1
    if (pos > 0 and neg == 0):
        same=copy_(true)
    if (neg > 0 and pos == 0):
        same=copy_(true)
    return same
